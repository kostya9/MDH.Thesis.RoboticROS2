env int msgDelay = 50;
env int moveDelay = 1000;

env int MAPSIZE = 20;

env double laserDist = 3;
env double INFINITY = 9999;
env int lasers = 10;
env double pi = 3.14;
env double minAngle = pi / 4;
env double maxAngle = 3 * pi / 4;
env double angleIncrement = (maxAngle - minAngle) / lasers;
env double laserLength = 10;
env double steps = 20;
env double stepLength = steps / laserLength;

env int COLLISION = -1;


// ROTATIONS
env int NORTH = 0;
env int EAST = 1;
env int SOUTH = 2;
env int WEST = 3;

reactiveclass RobotHardware(10) {
	knownrebecs {
		Robot robot;
	}
	
	statevars {
		int[20][20] map;
		int posX;
		int posY;
		int rot;
		boolean moving;
		
		// variables for assertion
		int prevPosX;
		int prevPosY;
		int prevRot;
		boolean isFirstState;
	}
	
	RobotHardware()
	{
		moving = true;
		isFirstState = true;
		
		setCollisions();
		laserScanSend();
		moveActuator() after(moveDelay);
	}
	
	// USE THIS METHOD TO SET COLLISIONS ON THE MAP
	void setCollisions() { 
		map[0][1] = COLLISION;
	}
	
	double tan(double angle) {
		if(angle > (pi / 2)) {
			angle = angle - pi;
		}
		
		double x = angle;
		// taylor series expansion
		return x + x*x*x / 3 + 2*x*x*x*x*x/15; 
	} 
	
	double sqrt(double x) {
		// taylor series expansion
		return 1 + (x-1) + (x-1)*(x-1)/2 + (x-1)*(x-1)*(x-1)/6; 
	}
	
	double getDistanceToCollision(double dy, double curAngle) {
		// f(x) = kx
		// x = f(x) / k
		// where k - the tangent of tilt angle
		double dx = dy / tan(curAngle);
		double turnedX, turnedY;
				
		if(rot == NORTH)
		{
			turnedX = dx;
			turnedY = dy;
		}
		else if(rot == EAST)
		{
			turnedX = -dy;
			turnedY = dx;
		}
		else if(rot == SOUTH)
		{
			turnedX = -dx;
			turnedY = dy;
		}
		else if (rot == WEST)
		{
			turnedX = dy;
			turnedY = -dx;
		}
		
		int yIndx = posY + (int)dy;
		int xIndx = posX + (int)dx;
		
		// check collision with end of map
		if ((yIndx >= 20) || (yIndx < 0)) {
			return 0;
		}
		
		// check collision with end of map
		if((xIndx >= 20) || (xIndx < 0)) {
			return 0;
		}
		
		if(map[xIndx][yIndx] == COLLISION) {
			return sqrt(dy * dy + dx * dx);
		}
		
		return INFINITY;
	}
	
	// Send laser data to robot software
	msgsrv laserScanSend() {
		double[10] dists;
		// init array
		for(int i = 0; i < lasers; i++) {
			dists[i] = INFINITY;
		}

		// for each laser 
		// go through distances from 0 to laserLength
		// and if there is collision (and it is the first collision) 
		//     write the distance to it
		// else
		//     do nothing
		double curAngle = minAngle;
		for(int i = 0; i < lasers; i++) {
		
			// test the cells for collision where f(x) = dy
			// f(x) - laser ray function
			for (double dy = 0; dy <= laserLength; dy += stepLength) {
				if(dists[i] == INFINITY) {
					dists[i] = getDistanceToCollision(dy, curAngle);
				}
			}
			curAngle = curAngle + angleIncrement;
		}
		
		robot.onLaserScan(posX, posY, rot, moving, dists);
		
		self.laserScanSend() after(msgDelay);
	}
	
	// Move the actual robot (change pos)
	msgsrv moveActuator() {	
		// no movement when finished
		if(moving)
		{
			int dx, dy;
			if(rot == NORTH)
			{
				dx = 0;
				dy = 1;
			}
			else if(rot == EAST)
			{
				dx = 1;
				dy = 0;
			}
			else if(rot == SOUTH)
			{
				dx = 0;
				dy = -1;
			}
			else if (rot == WEST)
			{
				dx = -1;
				dy = 0;
			}
			
			self.prevPosX = posX;
			self.posX += dx;
			self.prevPosY = posY;
			self.posY += dy;
		}
		
		self.isFirstState = false;
		moveActuator() after(moveDelay);
	}
	
	msgsrv move() {
		moving = true;
	}
	
	msgsrv stop() {
		moving = false;
	}
	
	msgsrv turnLeft() {
		prevRot = rot;
		rot = (rot - 1) % 4;
	}
	
	msgsrv turnRight() {
		prevRot = rot;
		rot = (rot + 1) % 4;
	}
}

reactiveclass Pathfinder(11)
{
	statevars {
		int xPos;
	    int yPos;
	    double curYaw;
	    boolean[20][20] map;
	    int[20][20] parents;
	    
	    int[127] openList;
	    int[127] closedList;
	    double[20][20] hs;
	    double[20][20] gs;
	    double[20][20] fs;
	    int[127] curPath;
	    
	    boolean changed;
	}
	
	Pathfinder() {
		clearList(openList);
		clearList(closedList);
		clearList(curPath);
	}
	
	msgsrv setPosition(int nextxPos, int nextyPos, int rot) {
		self.xPos = nextxPos;
		self.yPos = nextyPos;
		if(rot == NORTH)
		{
			self.curYaw = pi/2;
		}
		else if(rot == EAST)
		{
			self.curYaw = 0;
		}
		else if(rot == SOUTH)
		{
			self.curYaw = -pi/2;
		}
		else if (rot == WEST)
		{
			self.curYaw = pi;
		}
	}
	
	double sqrt(double x) {
		// taylor series expansion
		return 1 + (x-1) + (x-1)*(x-1)/2 + (x-1)*(x-1)*(x-1)/6; 
	}
	
	double distTo(double x, double y, double xTarget, double yTarget) {
		double dy = y - yTarget;
		double dx = x - xTarget;
		return sqrt(dy * dy + dx * dx);
	}
	
	void clearList(int[127] list) {
		for(int i = 0; i < 127; i++) {
			list[i] = -1;
		}
	}
	
	void addToList(int[127] list, int value) {
		boolean added = false;
		for(int i = 0; i < 127; i++) {
			if(list[i] == -1) {
				added = true;
				list[i] = value;
				break;
			}
		}
		
		assertion(added, "buffer overflow");
	}
	
	int removeFromList(int[127] list, int idx) {
		int lastIdx = 126; 
		for(int i = 0; i < 127; i++) {
			if(list[i] == -1) {
				lastIdx = i;
				break;
			}
		}
		
		// Swap with the last element
		// and erase new last element
		int toDelete = list[idx];
		list[idx] = list[lastIdx];
		list[lastIdx] = -1;
		
		return toDelete;
	}
	
	int findIdxInList(int[127] list, int value) {
		for(int i = 0; i < 127; i++) {
			if(list[i] == value) {
				return i;
			}
			
			if(list[i] == -1) {
				return -1;
			}
		}
		
		return -1;
	}
	
	int size(int[127] list) {
		for(int i = 0; i < 127; i++) {
			if(list[i] == -1) {
				return i;
			}
		}
		
		return 127;
	}
	
	double cos(double x) {
		return 1 - x*x/2 + x*x*x*x/24;
	}
	
	double sin(double x) {
		return 1 - x*x*x/6 + x*x*x*x*x/120;
	}
	
	int posToIdx(int x, int y) {
		return x + y * 20;
	}
	
	int idxToY(int idx) {
		return idx / 20;
	}
	
	int idxToX(int idx) {
		return idx % 20;
	}
	
	int idxOfSmallestF() {
		int smallestIdx = 0;
		double smallestF = openList[0];
		for(int i = 0; openList[i] != -1; i++) {
			int cur = openList[i];
			int x = idxToX(cur);
			int y = idxToY(cur);
			double curF = fs[x][y];
			if(curF < smallestF) {
				smallestF = curF;
				smallestIdx = i;
			}
		}
		
		return smallestIdx;
	}
	
	int[127] generatePathFromTarget(int xTarget, int yTarget) {
		int[127] path;
		clearList(path);
		
		int els = 0;
		int x = xTarget;
		int y = yTarget;
		while(true) {
			int parent = parents[x][y];
			addToList(path, parent);
			els++;
		}
		
		// Reverse the path;
		for(int idx = 0; idx < els / 2; idx++) {
			int endElIdx = els - idx - 1;
			int endEl = path[endElIdx];
			path[endElIdx] = path[idx];
			path[idx] = endEl;
		}
	}
	
	msgsrv calcPath(int xTarget, int yTarget) {
		if(self.changed) {
			int curPos = posToIdx(xPos, yPos);
			addToList(openList, curPos);
			
			while(size(openList) != 0) {
				int curOpenListIdx = idxOfSmallestF();
				int curNodeIdx = removeFromList(openList, curOpenListIdx);
				addToList(closedList, curNodeIdx);
				
				int x = idxToX(curNodeIdx);
				int y = idxToY(curNodeIdx);
				if(x == xTarget && y == yTarget) {
					int[127] path = generatePathFromTarget(xTarget, yTarget);
					((Robot)sender).onNewPath(path);
					break;
				}
				
				// for each neighbor
				for(int dx = -1; dx <= 1; dx++) {
					for(int dy = -1; dy <= 1; dy++) {
						
						// IGNORE DIAGONALS
						// TODO: HANDLE DIAGONALS
						if(dx + dy != 1 && dx + dy != -1) {
							continue;
						}
					
						int neighborX = x + dx;
						int neighborY = y + dy;
						
						if(neighborX < 0 || neighborX >= 20 ||
							neighborY < 0 || neighborY >= 20) {
							continue;
						}
						
						double g = gs[x][y] + 1; // TODO: handle diagonals
						double h = distTo(x, y, xTarget, yTarget);
						double f = g + h;
						
						int neighborIdx = posToIdx(x, y);
						int alreadyInOpenList = findIdxInList(openList, neighborIdx);
						if(alreadyInOpenList != -1) {
							if(g > gs[neighborX][neighborY]) {
								continue;
							}
						}
						
						parents[neighborX][neighborY] = curNodeIdx;
						gs[neighborX][neighborY] = g;
						hs[neighborX][neighborY] = h;
						fs[neighborX][neighborY] = f;
					}
				}
			}
		}
	}
	
	msgsrv addCollision(double distance, double dYaw) {
		double yaw = self.curYaw + dYaw;
	    double targetX = self.xPos + distance * cos(yaw);
	    double targetY = self.yPos + distance * sin(yaw);
	
	    double targetXIndex = (int)(targetX);
	    double targetYIndex = (int)(targetY);
	
	    if(targetXIndex < 0 || targetXIndex >= MAPSIZE || 
	        targetYIndex < 0 || targetYIndex >= MAPSIZE) 
	    {
	       // out of bounds
	    } else {
	    	if(!map[targetXIndex][targetYIndex]) {
	    		self.changed = true;
	    	}
 	    	map[targetXIndex][targetYIndex] = true;
	    }
	}
}

reactiveclass Robot(10) {
	knownrebecs {
		RobotHardware rh;
		Pathfinder pf;
	}
	
	statevars {
		int targetX;
		int targetY;
		boolean finish;
		int[127] path;
		int curPathIdx;
	}
	
	Robot(int x, int y) {
		self.targetX = x;
		self.targetY = y;
	}

	// Straightforward algorithm - just follow target, no collision avoidance
	msgsrv onLaserScan(int posX, int posY, int rot, boolean moving, double[10] laserDistances) {
		if(!finish) {
			pf.setPosition(posX, posY, rot);
			
			double curAngle = minAngle;
			for(int i = 0; i < 10; i++) {
				pf.addCollision(laserDistances[i], curAngle);
				curAngle = curAngle + angleIncrement;
			}
			
			pf.calcPath(self.targetX, self.targetY);
			moveNaive(posX, posY, rot, moving);
		}
	}
	
	void moveNaive(int posX, int posY, int rot, boolean moving) {
		int nextX = path[curPathIdx] % 20;
		int nextY = path[curPathIdx] / 20;
		curPathIdx++;
		if(posX == nextX && posY == nextY) {
			if(!finish) {
				rh.stop();
				finish = true;
			}
		} else {
			boolean stop = false;
			if(nextY > posY) {
				if(rot != NORTH) {
					rh.turnRight();
					stop = true;
				}
			}
			else if(nextY < posY) {
				if(rot != SOUTH) {
					rh.turnRight();
					stop = true;
				}
			}
			else if(nextX > posX) {
				if(rot != EAST) {
					rh.turnRight();
					stop = true;
				}
			}
			else if(nextX < posX) {
				if(rot != WEST) {
					rh.turnRight();
					stop = true;
				}
			}
			
			if(stop) {
				rh.stop();
			}
			else if(!moving) {
				rh.move();
			}
		}
	}
	
	msgsrv onNewPath(int[127] newPath) {
		self.path = newPath;
		self.curPathIdx = 0;
	}
}

main {
	Pathfinder pf():();
	Robot r(rh, pf):((int)5, (int)2);
	RobotHardware rh(r):();
}